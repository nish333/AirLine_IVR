package flow;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;

import com.avaya.sce.runtime.tracking.TraceInfo;
import com.avaya.sce.runtimecommon.ITraceInfo;
import com.avaya.sce.runtimecommon.SCESession;

import beans.AppConstant;
import beans.DatabaseManager;

/**
 * The Data class handles many types of server-side operations including data
 * collection (from a data sources such as a database, or web service), variable
 * assignments and operations (like copying variable values, performing mathematic
 * operations, and collection iteration), conditional evaluation to control callflow
 * execution based on variable values, and logging/tracing statements.
 * 
 * Items created in the getDataActions() method are executed/evaluated in order
 * and if a condional branch condition evaluates to "true" then the branch is
 * activated and the execution of data actions is halted.  If no "true" conditions
 * are encountered, then all data actions will be executed/evaluated and the 
 * application will proceed to the "Default" servlet.
 * Last generated by Orchestration Designer at: 2024-JUL-04  01:31:07 PM
 */
public class NextInCollection extends com.avaya.sce.runtime.Data {

	//{{START:CLASS:FIELDS
	//}}END:CLASS:FIELDS

	/**
	 * Default constructor
	 * Last generated by Orchestration Designer at: 2024-JUL-04  01:31:07 PM
	 */
	public NextInCollection() {
		//{{START:CLASS:CONSTRUCTOR
		super();
		//}}END:CLASS:CONSTRUCTOR
	}
	

	/**
	 * Returns the Next item which will forward application execution
	 * to the next form in the call flow.
	 * Last generated by Orchestration Designer at: 2024-JUL-31  05:04:31 PM
	 */
	public com.avaya.sce.runtime.Next getNext(com.avaya.sce.runtimecommon.SCESession mySession) {
		com.avaya.sce.runtime.Next next = new com.avaya.sce.runtime.Next("TripDetailsPrompt", "Default");
		next.setDebugId(396);
		return next;
	}
	/**
	 * Create a list of local variables used by items in the data node.
	 * 
	 * This method is generated automatically by the code generator
	 * and should not be manually edited.  Manual edits may be overwritten
	 * by the code generator.
	 * Last generated by Orchestration Designer at: 2024-JUL-31  05:04:31 PM
	 */
	public java.util.Collection<VariableInfo> getLocalVariables(){
		java.util.Collection<VariableInfo> variables = new java.util.ArrayList<VariableInfo>();

		return variables;
	}
	
	@Override
	public void requestBegin(SCESession mySession) {
	    super.requestBegin(mySession);

	    TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "ENTER INTO LAST FEW TRIPS DETAILS RECORD", mySession);

	    DatabaseManager dbManager = new DatabaseManager(mySession);
	    Connection connection = null;
	    CallableStatement callableStatement = null;
	    ResultSet resultSet = null;

	    try {
	        connection = dbManager.getConnection();
	        TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "Database connection established successfully.", mySession);

	        String query = AppConstant.pnrdetails;
	        callableStatement = connection.prepareCall(query);

	        String customerIdStr = mySession.getVariableField(IProjectVariables.BOOKING_ID, IProjectVariables.BOOKING_ID_FIELD_VALUE).getStringValue();
	        callableStatement.setString(1, customerIdStr);
	        TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "Fetch customer ID: " + customerIdStr, mySession);

	        resultSet = callableStatement.executeQuery();

	        if (resultSet.next()) {
	            int uniqueId = resultSet.getInt(AppConstant.nuid);
	            String customerId = resultSet.getString(AppConstant.customerid);
	            String pnrNumber = resultSet.getString(AppConstant.pnrnumber);

	            String bookingDateStr = resultSet.getString(AppConstant.bookid).replace("-", "").replace(":", "").replace(" ", "").replace(".", "");
	            if (bookingDateStr != null && bookingDateStr.length() >= 14) {
	                String bookingYear = bookingDateStr.substring(0, 4);
	                String bookingMonth = bookingDateStr.substring(4, 6);
	                String bookingDay = bookingDateStr.substring(6, 8);
	                String bookingHour = bookingDateStr.substring(8, 10);
	                String bookingMinute = bookingDateStr.substring(10, 12);
	                String bookingSecond = bookingDateStr.substring(12, 14);

	                TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, 
	                 "Parsed BOOKING DATE:" + bookingDateStr + "\n" +
	                 "Year: " + bookingYear + "\n" +
	              	 "Month: " + bookingMonth  + "\n" +
	                 "Day: " + bookingDay  + "\n" +
	                 "Hour: " + bookingHour  + "\n" +
	                 "Minute: " + bookingMinute  + "\n" +
	                 "Second: " + bookingSecond ,
	                 mySession);

	                mySession.getVariableField(IProjectVariables.YEAR).setValue(bookingYear);
	                mySession.getVariableField(IProjectVariables.MONTH).setValue(bookingMonth);
	                mySession.getVariableField(IProjectVariables.DATEE).setValue(bookingDay);
	                mySession.getVariableField(IProjectVariables.HOURS).setValue(bookingHour);
	                mySession.getVariableField(IProjectVariables.MINUTES).setValue(bookingMinute);
	                mySession.getVariableField(IProjectVariables.SECONDS).setValue(bookingSecond);
	            } else {
	                TraceInfo.trace(ITraceInfo.TRACE_LEVEL_ERROR, "Booking date string is not in the expected format: " + bookingDateStr, mySession);
	            }

	            String departureDateStr = resultSet.getString(AppConstant.departureid).replace("-", "").replace(":", "").replace(" ", "").replace(".", "");
	            if (departureDateStr != null && departureDateStr.length() >= 14) {
	                String departureYear = departureDateStr.substring(0, 4);
	                String departureMonth = departureDateStr.substring(4, 6);
	                String departureDay = departureDateStr.substring(6, 8);
	                String departureHour = departureDateStr.substring(8, 10);
	                String departureMinute = departureDateStr.substring(10, 12);
	                String departureSecond = departureDateStr.substring(12, 14);

	                TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, 
	                "Parsed DEPARTURE DATE:" + departureDateStr + "\n" +
	                "Year: " + departureYear + "\n" +
	                "Month: " + departureMonth + "\n" +
	                "Day: " + departureDay + "\n" +
	                "Hour: " + departureHour + "\n" +
	                "Minute: " + departureMinute + "\n" +
	                "Second: " + departureSecond, 
	                mySession);

	                mySession.getVariableField(IProjectVariables.YEAR).setValue(departureYear);
	                mySession.getVariableField(IProjectVariables.MONTH).setValue(departureMonth);
	                mySession.getVariableField(IProjectVariables.DATEE).setValue(departureDay);
	                mySession.getVariableField(IProjectVariables.HOURS).setValue(departureHour);
	                mySession.getVariableField(IProjectVariables.MINUTES).setValue(departureMinute);
	                mySession.getVariableField(IProjectVariables.SECONDS).setValue(departureSecond);
	            } else {
	                TraceInfo.trace(ITraceInfo.TRACE_LEVEL_ERROR, "Departure date string is not in the expected format: " + departureDateStr, mySession);
	            }

	            String transactionStatus = resultSet.getString(AppConstant.status);

	            mySession.getVariableField(IProjectVariables.UNIQUEID).setValue(uniqueId);
	            mySession.getVariableField(IProjectVariables.CUSTOMERID).setValue(customerId);
	            mySession.getVariableField(IProjectVariables.PNRNUMBER).setValue(pnrNumber);
	            mySession.getVariableField(IProjectVariables.STATUS).setValue(transactionStatus);

	            TraceInfo.trace(
	                ITraceInfo.TRACE_LEVEL_INFO,
	                "Unique ID: " + uniqueId + "\n" +
	                "Customer ID: " + customerId + "\n" +
	                "PNR Number: " + pnrNumber + "\n" +
	                "Booking Date: " + bookingDateStr + "\n" +
	                "Departure Date: " + departureDateStr + "\n" +
	                "Status: " + transactionStatus,
	                mySession
	            );

	        } else {
	            TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "No trip details found for customer ID: " + customerIdStr, mySession);
	        }

	        TraceInfo.trace(ITraceInfo.TRACE_LEVEL_INFO, "Fetched previous trip details successfully from the database", mySession);

	    } catch (SQLException e) {
	        TraceInfo.trace(ITraceInfo.TRACE_LEVEL_ERROR, "SQL Error while fetching data from the database: " + e.getMessage(), mySession);
	        mySession.getVariableField(IProjectVariables.USER_INPUT).setValue("");
	    } catch (Exception e) {
	        TraceInfo.trace(ITraceInfo.TRACE_LEVEL_ERROR, "Error while fetching data from the database: " + e.getMessage(), mySession);
	        mySession.getVariableField(IProjectVariables.USER_INPUT).setValue("");
	    } finally {
	        try {
	            if (resultSet != null) {
	                resultSet.close();
	            }
	            if (callableStatement != null) {
	                callableStatement.close();
	            }
	            if (connection != null) {
	                connection.close();
	            }
	        } catch (SQLException e) {
	            TraceInfo.trace(ITraceInfo.TRACE_LEVEL_ERROR, "Error while closing resources: " + e.getMessage(), mySession);
	        }
	    }
	}

	
	/**
	 * Creates and conditionally executes operations that have been configured
	 * in the Callflow.  This method will build a collection of operations and
	 * have the framework execute the operations by calling evaluateActions().
	 * If the evaluation causes the framework to forward to a different servlet
	 * then execution stops.
	 * Returning true from this method means that the framework has forwarded the
	 * request to a different servlet.  Returning false means that the default
	 * Next will be invoked.
	 * 
	 * This method is generated automatically by the code generator
	 * and should not be manually edited.  Manual edits may be overwritten
	 * by the code generator.
	 * Last generated by Orchestration Designer at: 2024-JUL-31  05:04:31 PM
	 */
	public boolean executeDataActions(com.avaya.sce.runtimecommon.SCESession mySession) throws Exception {
		java.util.Collection actions = null;

		actions = new java.util.ArrayList(3);
		actions.add(new com.avaya.sce.runtime.tracking.TraceInfo(com.avaya.sce.runtimecommon.ITraceInfo.TRACE_LEVEL_DEBUG, "ENTER INTO NEXT IN COLLECTION", "").setDebugId(416));
		actions.add(new com.avaya.sce.runtime.varoperations.NextInCollection("BookingId").setDebugId(398));
		if(evaluateActions(actions, mySession)) {
			return true;
		}
		actions = null;

		// return false if the evaluation of actions did not cause a servlet forward or redirect
		return false;
	}
}
